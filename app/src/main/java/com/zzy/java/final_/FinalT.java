package com.zzy.java.final_;

/**
 * Created by BCLZzy on 2017/9/28.
 * 方法传参为final类型
 *
 * 1、final修饰的类不可有子类，例如java.lang。Math类就是一个final类，它不可以有子类。
 * 2、final修饰的基本类型不能被改变。
 * 3、但对于引用类型的变量而言，它保存的仅仅是一个引用，final只保证这个引用所引用的地址不会改变，
 *      即一直引用同一个对象，但这个对象完全可以发生改变。
 *          final int[] iArr={6,8,9,10}
 *              Arrays.sort（iArr）;//对数组进行排序，合法
 *              iArr[2]=-8;//对数组元素赋值，合法
 *              iArr=null；对iArr重新赋值，非法
 *          final User user = new User();//由于是final的，所以必须初始化。
 *              user.setName("张");//修改对象属性，合法
 *              user = new User();//修改对象引用地址，非法
 */
public class FinalT {


    /*
    值A 做为参数传递给方法方法A，当方法A中的值A改变时，原本的值A是否跟着改变

    http://www.cnblogs.com/linkstar/p/5951141.html  经典讲解
    那么方法中什么时候会改变原来的值，什么时候不会呢？
    1、只要是基本类型，传递的是值，这个值是复制了一份出来的，所以怎么都不会改变。
    2、引用类型，传递的是地址，如果这个地址变了，那么原来的值肯定不变。
    3、引用类型，传递的是地址，如果地址没变，而改变了地址对应的对象的属性，那么就会改变原来的值。

     我的理解：
     当值A是 基本类型 时，原本的值A不会跟随方法中值A的改变而改变。
     当值A是 引用类型 时，原本的值A会跟随方法中值A的改变而改变。

    基本类型有：byte short int long float double char boolean
    引用类型有三种： 类class  接口interface  数组array
    类class包括自定义类、Object、String、 Date、Integer、Long、Boolean、Byte、Character、Double、Float、Short

    网上解释：
    想理解传值调用传引用调用应该理解 栈内存和堆内存，
    基本类型 和 指针（java中叫引用名称） 存在占内存中，引用名词的具体值存放在堆内存中，，，所有的方法，调用的时候都会拷贝，
    你说那个基本类型是拷贝，引用类型是指向，不太确切，，，其实 当方法调用时候，方法的参数照样会在占内存中开辟一块新的区域，
    同时把要传递的基本类型，或者应用类型名称，复制（注意，统统是复制，而不存在有的复制，有的指向这一说）。。。结果是，
    普通类型（存放在占内存中的）复制之后的值改变了，但与原来的已无关（这点跟你的理解一样），，
    但是引用类型，把复制后的引用名词（虽然是复制，但是依然和原来的指向同一块堆内存区域），
    找到堆内存的区域，改变他（这和你的理解结果是一样的，内存形态有所改变）
     */

}
